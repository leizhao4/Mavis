\chapter{Algorithms}\label{chap:Algorithms}

The algorithm of color computation consists of five stages. First, multidimensional scaling reduces the number of dimensions and convert the confidence/similarity scores into coordinates. Second, coordinates are mapped onto part of the CIE Lab color space\cite {McLAREN:1976aa}, and colors are created. Third, colors are flipped and rotated to smooth the graph and remove color noises. Finally, calculate the average color/hue of each sequence, sort them, and output for further display.

\section{Multidimensional Scaling}

This stage begins with the confidence scores described above. Each column in the MSA has a complete set $C$ of pairwise scores. Each pair of non-gap symbols $i,j$ in this column has a score $c_{ij} \in [0,1]$. Here 1 stands for absolute confidence or similarity, while 0 for the opposite.

This set $C$ can be easily converted to a dissimilarity score, or a distance $D$, between the two symbols, by $D=1-S$. All these distances within a column can be re-organized as a symmetric distance matrix.

We try to map all the symbols to a two-dimensional space, in which they still preserve their distances as much as possible. This procedure involves a statistical technique called classic multidimensional scaling, also known as Torgerson-Gower Scaling or Principle Coordinates Analysis (Gower, 1966). Multidimensional scaling takes a distance matrix and assigns a coordinate to each item in a lower dimensional space, such that the Euclidean distance between any two coordinates is approximately equal to the dissimilarity score between the corresponding items.

An R function called cmdscale() is utilized in the multidimensional scaling procedure. The function is written in R, which is a programming language for statistical computing (Ihaka and Gentleman 1996), and is provided in R’s stat package. It reads a distance matrix and returns a set of points in a k-dimensional space, where k is a user-defined parameter to the function, and must be less than the number of points. (Becker et al. 1988, Cailliez 1983, Cox and Cox 2001)

Here is our approach, k is set to 2, meaning the distance matrix should be scaled to a two-dimensional space. However, a column in a multiple sequence alignment, which represents an equivalent position across all the sequences, can contain only one or two non-gap symbols, so that the column has only one or two points. In such cases, k=2 is not a valid parameter because k must be less than the number of points, so k should be set to zero (for one point) or one (for two points), and the missing coordinates should be filled by zeros.

The input data set represents the similarities between symbols, while the multidimensional scaling procedure requires the dissimilarities (or distances). We simply convert similarity (S) to dissimilarity (D) by D = 1 - S and pass the converted matrix to the cmdscale() function.

\section{Color Space Mapping}

The multidimensional scaling procedure returns a set C of coordinates on a two-dimensional space, representing the symbols in a multiple sequence alignment. We further map this two-dimensional space into an three-dimensional CIE Lab color space.

The CIE Lab color space is a color-opponent space. The name Lab stands for the three dimensions: L for lightness, and a and b for the color opponents based on nonlinearly compressed CIE XYZ color space coordinates. Compared to the RGB and CMYK color models, the design of Lab color emphasizes more on approximating human vision rather than physical devices. This feature makes it suitable for our visualization purpose.

Since the data set C from the previous procedure contains only two-dimensional coordinates, and we only use the most visible colors instead of the whole color space, the dimension L for lightness is set to 75. The two dimensions from data set C are scaled from [0,1] to [0, 100] and used as color opponents a and b.

\section{Hue Rotation and Optimization}

One of the limitations in the previous multiple sequence alignment visualization techniques is the unnecessary color difference among columns, which doesn’t represent any biological dissimilarity but introduces much confusion to the analysis. To minimize this effect, we convert the colors from CIE Lab space to CIE LCH space, perform rotations and minimize the the sum of hue variances of all the sequences. This procedure eliminates between-column color differences to the greatest extent possible, smooth the color pattern and emphasize the real similarities and dissimilarities among sequences and blocks.

The CIE LCH color space, also known as polar-Lab color space, is a transformation of the CIE Lab space so that the a and b axles are converted to a polar coordinate system, which makes it easier to rotate. The radial coordinate C measures chroma and the angular coordinate H measures hue. The CIE LCH colors can be converted from CIE Lab colors using an R library called colorspace.

The fact that 0 and 2π are identical angles, so that given two angles p and q, the difference between them can be calculated by
diff(t1, t2) = (p - q + π) mod 2π - π
This gives the difference in the interval [-π, π), or in degrees [-180°, 180°). The absolute value of the difference is in the interval [0, π], or in degrees [0, 180°]. Given a set A of angles a[i], i>=0, the average angle avg(A) is

%                                   sum_i_from_1_to_N sin(a[i])
%avg(A) = arctangent ---------------------------------------
%                                   sum_i_from_1_to_N cos(a[i])

and the variance var(A) is
%var(A) = sum_i_from_1_to_N(diff(a, a[i]) ^ 2) / N

Given an multiple sequence alignment M, with m rows and n columns, we look for a optimized set R of n rotation angles r[i], such that after rotating each hue in the ith column of the alignment clockwise by r[i], then the penalty function
%P = sum_j_from_1_to_m(var(all hues in the jth row))
is minimized.

The optimization procedure is performed with R’s general-purpose optimization function optim(). Among five available optimization algorithms, we choose the bounded Broyden-Fletcher-Goldfarb-Shanno (L-BFGS-B) method. This algorithm allows box constraints, meaning each variable can be given a lower and/or upper bound. Plus, it uses a limited amount of memory. The initial values are set to 0 and boundaries to [0, 2π]. More detailed comparison between different optimization functions and algorithms will be discussed later in Chapter 6.

\section{Hue Flipping}

One characteristic of the coordinates generated from multidimensional scaling is, they can not only be rotated, but also flipped, without changing the distances from each other. Adding flipping ability to the above rotation optimization procedure may result in lower penalty values and better coloring results. To keep the penalty function simple and fast, we perform an heuristic flipping before the rotation step.

For each ith column (2 <= i <= n), compare it to the previous one. Pick rows which exists in both columns and record the hues in two arrays H1 and H2. For each of the two arrays, compare each hue to the previous one using the diff() function described above. For each diff() > π/8, record a clockwise change; for each diff() < -π/8, record a counterclockwise change; otherwise leave it as an insignificant change. Within a column, if the number of clockwise changes is greater than the number of counterclockwise ones, call it a clockwise column, and vice versa. If two adjacent columns are in opposite types, flip the latter one to make them in same type.

After comparisons of all adjacent column pairs have been finished, no two pairs will be in opposite types, and the flipped data set is passed to the optimization procedure described above.

\section{Sequence Sorting}

The alignment graph is supposed to provide information on how sequences will group with each other. We sort sequences after coloring optimization, based on the average hue of each one, which is calculated by the average angle function avg() proposed previously.

Since the hue value is circular, where to break the sorted circle is a question. In the circle, we look for the biggest gap without any points in it, and break it at the midpoint. This keeps similar sequences together as much as possible.